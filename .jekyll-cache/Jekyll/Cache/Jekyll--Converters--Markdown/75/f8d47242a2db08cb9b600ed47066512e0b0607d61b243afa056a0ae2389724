I"¢"<p>In this article I will tell you a little more about automatic testing, a very important part of continuous integration. I explain concepts such as unit testing, integration testing, end to end testing, acceptance testing, TDD, BDD, code coverage</p>

<h1 id="from-validation-afterwards-to-designing-together">From validation afterwards to designing together</h1>
<p>There was a time when software development had a very tightly defined phase where testing was the last step . If there was any budget left then. In practice, this often turned into a lengthy ‚Äòit‚Äôs not a bug, it‚Äôs a feature‚Äô discussion. Nowadays, we tend to view testing as an integral part of software development and not a delineated topic. Automatic testing is now also an accepted and standard way of working.</p>

<blockquote>
  <p>Continuous delivery without testing is a bit like deploying your airbags and driving onto the A4 with a blindfold. You will see. I can‚Äôt think of any arguments not to test. The tooling is there, the knowledge about it is widespread and it just pays off.</p>

</blockquote>

<p>As an example for this article, we take a shopping card from a webshop:
<img src="/dear-non-it-people/assets/images/testing/testing-01.png" alt="testing" /></p>

<p>In principle, we are already looking at at least 4 features (where I leave the footer out of consideration), each of which has its own functionalities. All functionality together results in a customer being able to prepare his or her order and order something in the next step:</p>

<p><img src="/dear-non-it-people/assets/images/testing/testing-02.png" alt="testing" /></p>

<h1 id="unit-testing">Unit testing</h1>
<p><img src="/dear-non-it-people/assets/images/testing/testing-03.gif" alt="testing" /></p>

<p>Each feature or component has its own specific set of functions. For example adding up when you click on the plus sign next to the shoe or entering and checking a coupon code. We call testing all these functions unit testing. Ideally, a unit only does one thing. Let‚Äôs take the item price calculations as an example:</p>

<p><img src="/dear-non-it-people/assets/images/testing/testing-04.png" alt="testing" /></p>

<p>The first line indicates the total price, so the code for this will be something like:</p>
<blockquote>
  <p>Total price items = item price x quantity. So in this case 1 x 299.43.</p>
</blockquote>

<p>A unit test is a piece of code that checks every time the tests are run whether the code still does what it should do. In this case the test would look like this:</p>

<ul>
  <li>Suppose the item price is $ 50 and the quantity 3 then the expected total price of all items is $ 150</li>
  <li>Suppose the item price is $ 3.33 and the quantity 0 then the expected total price of all items $ 0, -</li>
</ul>

<p>In this example you only pay shipping costs if you order items under $ 300. The unit tests for this are:</p>

<ul>
  <li>Suppose the item price is $ 50 and the number 3 then the expected shipping costs are $ 40
(so the total price of the items is $ 150. This is less than $ 300 and so there must be shipping costs. paid)</li>
  <li>Suppose the item price is $ 50 and the number 7 then the expected shipping costs are $ 0, -</li>
</ul>

<p>We also do the same for the import costs and the total of the card. It is very nice to know that whatever we change in the code the calculations will at least be correct.</p>

<h1 id="tdd">TDD</h1>
<p>TDD stands for Test Driven Development. It is a way of working where you first write the test and only then the code. In order to be able to write the test initially, a developer must have a very good understanding of what the functionality should do.</p>

<p>The sentence: suppose the item price is $ 50 and the number 3 then the expected total price of all items is $ 150 gives a broader context and an example of what actually needs to be done. Making the functionality is a matter of passing this test.</p>

<h1 id="integration-testing">Integration testing</h1>
<p><img src="/dear-non-it-people/assets/images/testing/testing-05.gif" alt="testing" /></p>

<p>With integration testing we examine whether the cooperation between the features / components also works well. For example, we have to make sure that we pass on the total amount correctly to the credit card provider. But we must also thoroughly test the cooperation between the various components within a feature. You can compare it with a sentence. Every word is spelled correctly, but you will still have to check whether the whole (the sentence) is correct.</p>

<p>If we click on the plus next to the shoe, we expect the prices to be adjusted as well. In this case we test whether we get the correct numbers and not whether the plus works. After all, we have already covered the operation of the plus sign as a unit test (each click on the plus sign increases the number by one).</p>

<p><img src="/dear-non-it-people/assets/images/testing/testing-06.png" alt="testing" /></p>

<ul>
  <li>Suppose the item price is $ 70 and the quantity is 1, then the expected total price of all items is $ 70</li>
  <li>If the quantity in the top component changes to 2 then the expected total price of all items is $ 140</li>
</ul>

<p>End-2- end / acceptance tests / BDD / ATDD
These tests have the most in common with how the user experiences the software. We take a look at the behavior of the application here. Descriptions of these tests are also often written in human language.</p>

<p>BDD &amp; ATDD
BDD stands for Behavior Driven Development and ATDD for Acceptance Test Driven Development and is therefore the same as automatic acceptance testing. End-to-end means that we test the application from start to finish.</p>

<p>In all these cases, this means that we can describe the desired behavior in advance and automate its validation as part of the development process.</p>

<p>The great thing about this is that people from every discipline can contribute ideas and describe steps. It is very enlightening to think in advance which steps a user takes (a user journey) and what choices we can make in advance. It is best to start with a happy path (the ideal user journey without complications) and come up with variants:</p>

<p>The test to test the coupon functionality:
Suppose I have 1 x Nike Zoom blue 1 x Nike Zoom red in the shopping cart put,
when I was on the heart then, 
then I see that the heart becomes red,
when Ithe code‚ÄôBLABLABLA_FOUTE_CODE‚Äôjoined the coupon,
I Applyfill-click, 
then I see the error message ‚ÄúYour coupon is not</p>

<p>correct,‚ÄùAnd in the case of a correct code:
‚Ä¶
When I enter the code ‚ÄòXzOp014524BDZ‚Äô in the coupon,
and I click Apply, 
I see the message ‚ÄòCongrats, you receive an 25% discount!‚Äô
And my total price is $ 575.15</p>

<p>Cucumber
Maybe you‚Äôve heard your team talk about Cucumber and thought that was strange since it was a long way from lunch time. Cucumber is simply a tool that has been around for some time with which you can do BDD &amp; ATDD tests. Although Cucumber is well known, many automatic testing tools have been added in recent years.</p>

<p>Code coverage
The code coverage is the number of relevant lines of code that are tested. Often a number like 80% is used, but there are also plenty of teams that want to keep the coverage around 100%. When this coverage becomes too low, you can cause the pipeline to stop. However, coverage does not say anything about the quality of the tests! You can also write bad automatic tests again. Something that can help with this (testing for your tests) are mutation tests, but that goes too far for this article.</p>

<p>No guarantee
Although bugs can always occur in every application, and often at the most impossible moments, we have brought forward the time of testing by automating and we test many times more often. The automatic tests are done continuously by the developers, with every commit on the test and production servers.</p>

<p>In short, it provides the following advantages:
Thinking earlier about testing ensures a better architecture and user experience,
If something is difficult to test,often complex / too dependent on other code,
the code to be tested isBecause the code is tested it is easy for new developers to get up and running quickly,
You can definitely change pieces of code without breaking other parts,
The tests serve as documentation for how the application should work,
Fast and high frequency of feedback (The later you get a bug the more expensive it becomes),
By seeing testing more as a design pattern, it becomes something that can be done by the entire team, including stakeholders,
‚Ä¶</p>

<p>Do you have any questions / additions? Do you often hear arguments why your application / programming language / company is not suitable for testing? Leave a comment. Then we look at it together.</p>
:ET